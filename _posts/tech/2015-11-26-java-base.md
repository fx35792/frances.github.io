---
layout: post
title: 日常技术博客收集
category: 日常
keywords: Android,web
---
> Java基础日常记录

## 一 、Java中泛型使用

##### 1、首先我们来一个例子，由此来引出泛型的概念
```java
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("1");
        //list.add(false);//1
        list.add(100);//2
        int len = list.size();
        for (int i = 0; i < len; i++) {
            String value = (String) list.get(i); // 1
            System.out.println("value:" + value);
        }
    }
```
以上代码就不用解释了，大家一看就明白，但是会出异常,信息如下

```java
代码1处：
value:1Exception in thread "main" 
java.lang.ClassCastException: java.lang.Boolean cannot be cast to java.lang.String
    at MianTest.main(MianTest.java:16)
代码2处：   
value:1
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
    at MianTest.main(MianTest.java:16)
```
以上代码存在两个问题：
* 集合不会记住此对象的类型
* 强制转换类型会出错

##### 2、泛型
泛型，即“参数化类型”一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。
顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
常常用T、E、K、V等形式的参数常用于表示泛型形参，用来接收来自外部使用时候传入的类型实参<br/>

* T为形参，外部可以传进来实参

```java
public class GenericModel<T> {
    private T mData;

    public GenericModel(T t) {
        this.mData = t;
    }

    public T getData() {
        return mData;
    }

    public void setmata(T mData) {
        this.mData = mData;
    }

}
```
具体使用：
```
public static void main(String[] args) {
        GenericModel<Boolean> z = new GenericModel<Boolean>(false);
         GenericModel<String> one = new GenericModel<String>("1");
         GenericModel<Integer> two = new GenericModel<Integer>(1);
         System.out.println("z"+z.getData());
         System.out.println("one"+one.getData());
         System.out.println("two"+two.getData());
}
```

结果：

```java
zfalse
oneaaa
two1
```

问题1: 那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？<br/>
  答:泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型

##### 3、补充

我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型，当然，在逻辑上我们可以理解成多个不同的泛型类型。

究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。
* [感谢Java总结篇系列：Java泛型](http://www.cnblogs.com/lwbqqyumidi/p/3837629.html)
* [使用demo请查看](https://github.com/whiskeyfei/Node-for-Android/tree/master/demo/%E6%B3%9B%E5%9E%8B)

***

#### 二、设计模式－观察者模式(java)
当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）
比如，当一个对象被修改时，则会自动通知它的依赖对象，观察者模式属于行为型模式。

#### 使用
在java中实现观察者模式需要用到java.util包中提供的Observable类和Observer接口，java已经给我们提供好类使用。
Observable可以查看java源码，下面是Observer接口

```java
/**
 * {@code Observer} is the interface to be implemented by objects that
 * receive notification of updates on an {@code Observable} object.
 *
 * @see Observable
 */
public interface Observer {

    /**
     * This method is called if the specified {@code Observable} object's
     * {@code notifyObservers} method is called (because the {@code Observable}
     * object has been updated.
     *
     * @param observable
     *            the {@link Observable} object.
     * @param data
     *            the data passed to {@link Observable#notifyObservers(Object)}.
     */
    void update(Observable observable, Object data);
}
```

#### demo 实例

###### 古董被观察，观察者为people用来观察古董价钱波动<br/>
* 被观察者需要继承Observable
* 维护内部数据即可

```java
public class Antique extends Observable {
    private float mPrice;// 价钱

    public Antique(float price) {
        this.mPrice = price;
    }

    public float getPrice() {
        return this.mPrice;
    }

    public void setPrice(float price) {
        super.setChanged();
        super.notifyObservers(price);// 价格被改变
        this.mPrice = price;
    }

    public String toString() {
        return "古董价格为：" + this.mPrice;
    }
}
```
* 观察者实现Observer接口，重写update方法即可

```java
public class People implements Observer{
    
    private String name;
    
    public People(String name) {
        this.name = name;
    }
    
    @Override
    public void update(Observable observable, Object data) {
        Log.e("","People update() -> update name:"+ this.name + ",price:"+ ((Float)data).floatValue());
    }

}
```

* 主函数调用

```
 Antique house = new Antique(1222f);
 People p1 = new People("p1");
 People p2 = new People("p2");
 People p3 = new People("p3");
 house.addObserver(p1);
 house.addObserver(p2);
 house.addObserver(p3);
 Log.e("", house+""); // 输出价格
 house.setPrice(111f);
 Log.e("", house+""); // 输出价格
```

#### 感谢

* [设计模式](http://www.runoob.com/design-pattern/observer-pattern.html)
* [Java常用类库--观察者设计模式(Observable类Observer接口)](http://www.2cto.com/kf/201310/253013.html)

####[demo实例](https://github.com/whiskeyfei/Node-for-Android/tree/master/demo/%E8%A7%82%E5%AF%9F%E8%80%85)

***

#### 三、Java 序列化

>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。
将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象,简单了说就是存储对象和读取对象

####实例
*  序列化对象并反序列化

```java
    String path = this.getFilesDir().getAbsolutePath() + File.separator + "data";
        Student sdudent = new Student("user","234");
        SerializableUtils.serialization(path, sdudent);
        Student student1 = (Student) SerializableUtils.deserialization(path);
        Log.e("", "student1"+student1.getName());
```
*  model实现Serializable

```java
public class Student implements Serializable {

    private static final long serialVersionUID = 1L;
    private String name;
    private String score;

    public Student(String name, String score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getScore() {
        return score;
    }

    public void setScore(String score) {
        this.score = score;
    }

}
```

* 序列化工具类（SerializableUtils）

```java
public class SerializableUtils {
    public SerializableUtils() {
        throw new AssertionError();
    }
    
    /**
     * Write Serializable datas
     * 
     * @param rsls
     * @param fileName
     * @param context
     * @throws IOException
     */
    @SuppressWarnings("deprecation")
    @SuppressLint("WorldReadableFiles")
    public static void write(Context context, Object rsls, String fileName)throws IOException {
        FileOutputStream fileOutputStream = context.openFileOutput(fileName,Context.MODE_WORLD_READABLE);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(rsls);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
    }

    /**
     * Read Serializable datas
     * 
     * @param fileName
     * @return
     * @throws Exception
     */
    public static Object read(Context context, String fileName)throws Exception {
        FileInputStream fileInputStream = context.openFileInput(fileName);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        Object object = objectInputStream.readObject();
        objectInputStream.close();
        fileInputStream.close();
        return object;
    }
    
    /**
     * serialize to file
     * 
     * @param filePath
     * @param obj model mast be implements Serializable
     * @throws RuntimeException if an error occurs
     */
    public static void serialization(String filePath, Object obj) {
        ObjectOutputStream out = null;
        try {
            out = new ObjectOutputStream(new FileOutputStream(filePath));
            out.writeObject(obj);
            out.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException("serialization() -> FileNotFoundException occurred.",e);
        } catch (IOException e) {
            throw new RuntimeException("serialization() -> IOException occurred",e);
        } finally{
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    throw new RuntimeException("serialization() -> IOException occurred. ", e);
                }
            }
        }
    }
    
    /**
     * deserialization from file
     * 
     * @param filePath
     * @return object implements Serializable
     * @throws RuntimeException if an error occurs
     */
    public static Object deserialization(String filePath){
        ObjectInputStream in = null;
        try {
            in = new ObjectInputStream(new FileInputStream(filePath));
            Object object = in.readObject();
            in.close();
            return object;
        } catch (FileNotFoundException e) {
            throw new RuntimeException("deserialization() -> FileNotFoundException occurrd",e);
        }catch (ClassNotFoundException e) {
            throw new RuntimeException("deserialization() -> ClassNotFoundException occurrd",e);
        }catch (IOException e) {
            throw new RuntimeException("deserialization() -> IOException occurrd",e);
        }
        finally{
            try {
                if (in != null) {
                    in.close();
                }
            } catch (IOException e) {
                throw new RuntimeException("IOException occurrd",e);
            }
        }
    }
    
}
```


####感谢
[Java 序列化](http://www.runoob.com/java/java-serialization.html)

#### [demo](https://github.com/whiskeyfei/Node-for-Android/tree/master/demo/%E5%BA%8F%E5%88%97%E5%8C%96)

***